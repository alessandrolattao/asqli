package cli

import (
	"fmt"
	"strings"

	"github.com/charmbracelet/lipgloss"
)

// View renders the UI
func (m Model) View() string {
	// History view takes over entire screen
	if m.state == stateHistory {
		return m.list.View() + "\n" + subtleStyle.Render("↑↓ navigate • Enter select • Ctrl+d clear history • Esc back")
	}

	// Info view takes over entire screen
	if m.state == stateInfo {
		return m.renderInfoView()
	}

	// Loading screen (connecting or loading schema)
	if m.state == stateConnecting || m.state == stateLoadingSchema {
		return m.renderLoadingScreen()
	}

	// Main screen with results and command bar
	return m.renderMainScreen()
}

// renderLoadingScreen renders the loading screen with centered logo and spinner
func (m Model) renderLoadingScreen() string {
	logo := `
   ░▒▓███████▓▒░░▒▓██████▓▒░░▒▓█▓▒░       ░▒▓██████▓▒░░▒▓█▓▒░
  ░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░
  ░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░
   ░▒▓██████▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓████████▓▒░▒▓█▓▒░
         ░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░
         ░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░
  ░▒▓███████▓▒░ ░▒▓██████▓▒░░▒▓████████▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░
                  ░▒▓█▓▒░`

	taglineStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#D3D3D3"))

	logoRendered := logoStyle.Render(logo)
	tagline := logoStyle.Render("                   ░▒▓██▓▒░") + taglineStyle.Render(" AI-POWERED SQL CLIENT")

	var statusMsg string
	if m.state == stateConnecting {
		statusMsg = m.spinner.View() + " Connecting to database..."
	} else {
		statusMsg = m.spinner.View() + " Loading schema..."
	}

	// Center everything vertically and horizontally
	content := lipgloss.JoinVertical(
		lipgloss.Center,
		logoRendered,
		tagline,
		"",
		spinnerStyle.Render(statusMsg),
	)

	return lipgloss.Place(
		m.width,
		m.height,
		lipgloss.Center,
		lipgloss.Center,
		content,
	)
}

// renderMainScreen renders the main screen with results area and command bar
func (m Model) renderMainScreen() string {
	// Calculate areas
	resultsHeight := m.height - CommandBarHeight

	// Render results area - fill the available space
	resultsArea := m.renderResultsArea(resultsHeight)

	// Ensure results area fills the height
	resultsAreaPadded := lipgloss.NewStyle().
		Height(resultsHeight).
		Render(resultsArea)

	// Render command bar
	commandBar := NewCommandBar(m.width, m.state, m.spinner, m.textInput, m.statusMessage, m.generatedSQL)
	commandBarView := commandBar.View()

	// Combine vertically - results area fills space, command bar at bottom
	return lipgloss.JoinVertical(
		lipgloss.Left,
		resultsAreaPadded,
		commandBarView,
	)
}

// renderResultsArea renders the results display area
func (m Model) renderResultsArea(height int) string {
	// Create padding style
	paddingStyle := lipgloss.NewStyle().Padding(1, 2)

	if m.table != nil {
		// Show table with navigation and padding
		tableView := m.table.View()
		return paddingStyle.Render(tableView)
	}

	// Show error or success message if no table
	// Check for generation errors (API errors, quota, etc.)
	if m.err != nil {
		errorStyle := lipgloss.NewStyle().
			Foreground(lipgloss.Color("196")).
			Bold(true)
		msg := errorStyle.Render("✗ AI Generation Error: " + m.err.Error())
		return paddingStyle.Render(msg)
	}

	// Check for execution errors (SQL errors)
	if m.currentError != nil {
		errorStyle := lipgloss.NewStyle().
			Foreground(lipgloss.Color("196")).
			Bold(true)
		msg := errorStyle.Render("✗ Query Execution Error: " + m.currentError.Error())
		return paddingStyle.Render(msg)
	}

	if m.currentResult != nil {
		successStyle := lipgloss.NewStyle().
			Foreground(lipgloss.Color("82")).
			Bold(true)
		msg := successStyle.Render("✓ Query executed successfully") + "\n" +
			subtleStyle.Render(fmt.Sprintf("(%d rows affected)", len(m.currentResult.Rows)))
		return paddingStyle.Render(msg)
	}

	// Empty state - show help
	helpMsg := lipgloss.NewStyle().
		Foreground(lipgloss.Color("240")).
		Render(strings.Join([]string{
			"Welcome to SQLAI!",
			"",
			"Ask me anything about your database in natural language,",
			"or use # prefix for raw SQL queries.",
			"",
			"Examples:",
			"  • show me all users",
			"  • # SELECT * FROM users LIMIT 10",
		}, "\n"))

	return lipgloss.Place(m.width, height, lipgloss.Center, lipgloss.Center, helpMsg)
}

// renderInfoView renders the query information view showing the last executed query.
// It displays both the user's original prompt and the SQL query generated by the AI,
// providing transparency into what was actually sent to the database.
func (m Model) renderInfoView() string {
	if len(m.queryHistory) == 0 {
		noInfoMsg := subtleStyle.Render("No query information available")
		return lipgloss.Place(m.width, m.height, lipgloss.Center, lipgloss.Center, noInfoMsg)
	}

	// Get the last query
	lastQuery := m.queryHistory[len(m.queryHistory)-1]

	// Styles
	titleStyle := lipgloss.NewStyle().
		Foreground(lipgloss.Color("#FFB6C1")).
		Bold(true).
		Padding(0, 1)

	labelStyle := lipgloss.NewStyle().
		Foreground(lipgloss.Color("#FFB6C1")).
		Bold(true)

	contentStyle := lipgloss.NewStyle().
		Foreground(lipgloss.Color("#E0E0E0")).
		Padding(0, 2)

	sqlStyle := lipgloss.NewStyle().
		Foreground(lipgloss.Color("#98C379")).
		Padding(0, 2)

	boxStyle := lipgloss.NewStyle().
		Border(lipgloss.RoundedBorder()).
		BorderForeground(lipgloss.Color("#FFB6C1")).
		Padding(1, 2).
		Width(m.width - 6)

	// Build content
	var content strings.Builder

	content.WriteString(titleStyle.Render("Last Query Information"))
	content.WriteString("\n\n")

	// User prompt
	content.WriteString(labelStyle.Render("User Prompt:"))
	content.WriteString("\n")
	content.WriteString(contentStyle.Render(lastQuery.Prompt))
	content.WriteString("\n\n")

	// Generated SQL
	content.WriteString(labelStyle.Render("Generated SQL:"))
	content.WriteString("\n")

	// Format SQL with line breaks if too long
	sqlLines := wrapText(lastQuery.SQL, m.width-10)
	for _, line := range sqlLines {
		content.WriteString(sqlStyle.Render(line))
		content.WriteString("\n")
	}

	// Debug information
	if len(lastQuery.Metadata) > 0 {
		content.WriteString("\n")
		content.WriteString(labelStyle.Render("Debug Info:"))
		content.WriteString("\n")

		// Model
		if model, ok := lastQuery.Metadata["model"].(string); ok {
			content.WriteString(contentStyle.Render(fmt.Sprintf("Model: %s", model)))
			content.WriteString("\n")
		}

		// Tokens
		if tokens, ok := lastQuery.Metadata["usage_tokens"].(int); ok {
			content.WriteString(contentStyle.Render(fmt.Sprintf("Tokens: %d", tokens)))
			content.WriteString("\n")
		}

		// Provider
		if provider, ok := lastQuery.Metadata["provider"].(string); ok {
			content.WriteString(contentStyle.Render(fmt.Sprintf("Provider: %s", provider)))
			content.WriteString("\n")
		}
	}

	content.WriteString("\n")
	content.WriteString(subtleStyle.Render("Press Esc to close"))

	boxed := boxStyle.Render(content.String())

	// Center the box
	return lipgloss.Place(m.width, m.height, lipgloss.Center, lipgloss.Center, boxed)
}

// wrapText wraps text to fit within the given width, attempting to break at natural boundaries.
// It prefers breaking at spaces, commas, or parentheses to maintain SQL readability.
func wrapText(text string, width int) []string {
	if len(text) <= width {
		return []string{text}
	}

	var lines []string
	for len(text) > width {
		// Find a good breaking point (space, comma, etc.)
		breakPoint := width
		for i := width; i > 0; i-- {
			if text[i] == ' ' || text[i] == ',' || text[i] == '(' || text[i] == ')' {
				breakPoint = i + 1
				break
			}
		}

		lines = append(lines, text[:breakPoint])
		text = text[breakPoint:]
	}

	if len(text) > 0 {
		lines = append(lines, text)
	}

	return lines
}
